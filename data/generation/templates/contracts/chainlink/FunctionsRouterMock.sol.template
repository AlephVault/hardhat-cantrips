// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol";
import "@openzeppelin/contracts/access/Ownable.sol";


/**
 * This is a mock over the IFunctionsRouter interface. It
 * will capture the requests and process them in an external
 * worker.
 */
contract FunctionsRouterMock is IFunctionsRouter, Ownable {
    /**
     * The constructor. Can be set up as needed.
     */
    constructor() Ownable(msg.sender) {
        // Feel free to setup your router as you please.
    }

    // This mock does not care about allow lists.
    function getAllowListId() external view returns (bytes32) {
        return bytes32(0);
    }

    // This mock does not care about allow lists.
    function setAllowListId(bytes32 allowListId) external {}

    // This mock does not care about admin fees.
    function getAdminFee() external view returns (uint72 adminFee) {
        return uint72(0);
    }

    // There will be no concept of gas limit validation in this mock.
    function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view {}

    // Mocks the contracts from the DON ids.
    mapping(bytes32 => address) private contractsByDonId;

    // Mocks the set of contracts' DON ids.
    bytes32[] private contractDonIds;

    // Mocks the PROPOSED contracts from the DON ids.
    mapping(bytes32 => address) private proposedContractsByDonId;

    // Mocks the set of proposed contracts' DON ids.
    bytes32[] private proposedContractDonIds;

    // Mocks the set of proposed contracts' from the values.
    address[] private proposedContractAddresses;

    /**
     * Returns the contract corresponding to a DON id.
     */
    function getContractById(bytes32 id) external view returns (address) {
        return contractsByDonId[id];
    }

    /**
     * Returns the proposed contract corresponding to a DON ids.
     */
    function getProposedContractById(bytes32 id) external view returns (address) {
        return proposedContractsByDonId[id];
    }

    /**
     * Gets the set of proposed contracts for the DON ids.
     */
    function getProposedContractSet() external view returns (bytes32[] memory, address[] memory) {
        return (proposedContractDonIds, proposedContractAddresses);
    }

    /**
     * Updates the set of proposed contracts.
     */
    function proposeContractsUpdate(
        bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses
    ) external onlyOwner {
        require(
            proposalSetIds.length == proposalSetAddresses.length,
            "FunctionsRouterMock: ids/addresses"
        );
        uint256 length = proposedContractDonIds.length;
        for(uint256 index = 0; index < length; index++) {
            delete proposedContractsByDonId[proposedContractDonIds[index]];
        }
        delete proposedContractDonIds;
        delete proposedContractAddresses;
        proposedContractDonIds = proposalSetIds;
        proposedContractAddresses = proposalSetAddresses;
    }

    /**
     * Updates the contracts from the proposed contracts.
     */
    function updateContracts() external onlyOwner {
        uint256 length = contractDonIds.length;
        for(uint256 index = 0; index < length; index++) {
            delete contractsByDonId[contractDonIds[index]];
        }
        delete contractDonIds;
        length = proposedContractDonIds.length;
        for(uint256 index = 0; index < length; index++) {
            contractsByDonId[proposedContractDonIds[index]] = proposedContractAddresses[index];
            contractDonIds.push(proposedContractDonIds[index]);
        }
    }

    // This mock does not care about pausing.
    function pause() external {}

    // This mock does not care about unpausing.
    function unpause() external {}

    ////////////////////////////////////////////////////////////////
    //////// Some utilities to fake some concepts.
    ////////////////////////////////////////////////////////////////

    /**
     * A mocked subscription.
     */
    struct Subscription {
        /**
         * The owner of the mocked subscription.
         */
        address owner;
    }

    /**
     * This event is emitted to enumerate mocked subscriptions.
     */
    event SubscriptionAdded(uint64 indexed subscriptionId, address owner);

    /**
     * A mapping of mocked subscriptions.
     */
    mapping(uint64 => Subscription) public subscriptions;

    /**
     * Adds a mocked subscription.
     */
    function addMockSubscription(uint64 subscriptionId, address owner) external onlyOwner {
        require(owner != address(0), "FunctionsRouterMock: invalid subscription owner");
        require(subscriptions[subscriptionId].owner == address(0), "FunctionsRouterMock: subscription already set");
        subscriptions[subscriptionId] = Subscription({owner: owner});
        emit SubscriptionAdded(subscriptionId, owner);
    }

    /**
     * A request, which can be fulfilled or not.
     */
    struct Request {
        /**
         * The don id.
         */
        bytes32 donId;

        /**
         * The subscription id.
         */
        uint64 subscriptionId;

        /**
         * The address of the client contract.
         */
        address clientContract;

        /**
         * The transaction initiator.
         */
        address txInitiator;

        /**
         * The request data.
         */
        bytes data;

        /**
         * The data version.
         */
        uint16 dataVersion;

        /**
         * Whether it is fulfilled or not.
         */
        bool fulfilled;

        /**
         * The result code.
         */
        FunctionsResponse.FulfillResult result;

        /**
         * The response.
         */
        bytes response;

        /**
         * The error.
         */
        bytes err;
    }

    /**
     * A mapping of mocked subscriptions.
     */
    mapping(bytes32 => Request) public requests;

    ////////////////////////////////////////////////////////////////
    //////// These methods serve for the mock's purpose:
    //////// Locally processing the function calls.
    ////////////////////////////////////////////////////////////////

    /**
     * Tells that a request was generated.
     */
    event RequestStart(
        bytes32 indexed requestId,
        bytes32 indexed donId,
        uint64 indexed subscriptionId,
        address subscriptionOwner,
        address requestingContract,
        address requestInitiator,
        bytes data,
        uint16 dataVersion,
        uint32 callbackGasLimit,
        uint96 estimatedTotalCostJuels,
        bool toProposed
    );

    /**
     * Sends the event that tells that a request was generated.
     */
    function _emitRequestStart(
        bytes32 requestId, bytes32 donId,
        uint64 subscriptionId, address subscriptionOwner,
        bytes memory data, uint16 dataVersion,
        uint32 callbackGasLimit, uint96 estimatedTotalCostJuels,
        bool toProposed
    ) private {
        emit RequestStart({
            requestId: requestId,
            donId: donId, subscriptionId: subscriptionId,
            subscriptionOwner: subscriptionOwner,
            requestingContract: msg.sender,
            requestInitiator: tx.origin, data: data,
            dataVersion: dataVersion,
            callbackGasLimit: callbackGasLimit,
            estimatedTotalCostJuels: estimatedTotalCostJuels,
            toProposed: toProposed
        });
    }

    /**
     * Tells that a request was processed.
     */
    event RequestProcessed(
        bytes32 indexed requestId,
        uint64 indexed subscriptionId,
        uint96 totalCostJuels,
        address transmitter,
        FunctionsResponse.FulfillResult resultCode,
        bytes response,
        bytes err,
        bytes callbackReturnData
    );

    /**
     * Sends a request, in the common nodes.
     */
    function _sendRequest(
        uint64 subscriptionId,
        bytes calldata data,
        uint16 dataVersion,
        uint32 callbackGasLimit,
        bytes32 donId,
        bool toProposed
    ) private returns (bytes32) {
        Subscription storage subscription = subscriptions[subscriptionId];
        require(subscription.owner != address(0), "FunctionsRouterMock: invalid subscription");
        bytes32 requestId = keccak256(abi.encodePacked(block.timestamp));
        _emitRequestStart(
            requestId, donId, subscriptionId, subscription.owner,
            data, dataVersion, callbackGasLimit, 0, toProposed
        );
        requests[requestId] = Request({
            donId: donId, subscriptionId: subscriptionId, clientContract: msg.sender,
            txInitiator: tx.origin, data: data, dataVersion: dataVersion, response: "",
            err: "", fulfilled: false, result: FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR
            // Actually, the result will be changed later.
        });
        return requestId;
    }

    /**
     * Sends a request, in the common nodes.
     */
    function sendRequest(
        uint64 subscriptionId,
        bytes calldata data,
        uint16 dataVersion,
        uint32 callbackGasLimit,
        bytes32 donId
    ) external returns (bytes32) {
        return _sendRequest(subscriptionId, data, dataVersion, callbackGasLimit, donId, false);
    }

    /**
     * Sends a request, in the proposed nodes. This will only
     * change an internal flag.
     */
    function sendRequestToProposed(
        uint64 subscriptionId,
        bytes calldata data,
        uint16 dataVersion,
        uint32 callbackGasLimit,
        bytes32 donId
    ) external returns (bytes32) {
        return _sendRequest(subscriptionId, data, dataVersion, callbackGasLimit, donId, true);
    }

    /**
     * Fulfills a request
     */
    function fulfill(
        bytes memory response,
        bytes memory err,
        uint96 juelsPerGas,
        uint96 costWithoutFulfillment,
        address transmitter,
        FunctionsResponse.Commitment memory commitment
    ) external onlyOwner returns (FunctionsResponse.FulfillResult, uint96) {
        // TODO implement.
        return (FunctionsResponse.FulfillResult.FULFILLED, uint96(0));
    }
}